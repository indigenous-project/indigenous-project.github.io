{"version":3,"sources":["views/discussions/DiscussionsAdd.js","server/CategoriesManagement.js","server/MediasManagement.js","server/DiscussionsManagement.js"],"names":["DiscussionsAdd","useState","categories","setCategories","mediaFile","setMediaFile","addingLoader","setaddingLoader","discussion","setDiscussion","toastMessages","setToastMessage","loadCategories","a","CallCategoriesList","response","json","Categories","data","handleAdd","ev","preventDefault","medias","addDiscussionCallback","mediaId","addObject","title","description","category","_id","isPublic","toString","AddDiscussion","ok","type","UploadMedia","useEffect","sm","id","className","Date","toDateString","action","method","onSubmit","htmlFor","required","placeholder","onInput","target","value","autoComplete","row","col","md","xs","name","onChange","files","custom","filter","map","tag","checked","color","defaultChecked","rows","size","toastMessage","position","show","autohide","fade","closeButton","Math","floor","random","bearerToken","localStorage","getItem","CategoriesList","fetch","GetUrl","mode","headers","Authorization","Accept","catch","error","console","log","message","CategoriesEdit","editObject","body","JSON","stringify","then","CategoriesDelete","CategoriesAdd","BUCKET_NAME","s3","AWS","S3","accessKeyId","secretAccessKey","MediasAdd","fileContent","callback","params","Bucket","Key","Body","ContentType","ACL","upload","err","extension","split","path","Location","jsonResult","UploadManyMedias","fileContents","promises","forEach","content","push","promise","Promise","all","pr","results","mediaIds","i","length","DiscussionsList","DiscussionsEdit"],"mappings":"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","file":"static/js/13.730f2546.chunk.js","sourcesContent":["\n\nimport React, { useState, useEffect } from 'react'\nimport { CToaster, CToastBody, CToastHeader, CToast, CInputFile, CSwitch, CSelect, CForm, CButton, CFormGroup, CCard, CSpinner, CCardBody, CCardFooter, CCol, CLabel, CRow, CInput, CFormText, CLink, CInputRadio, CImg, CTextarea }\n    from '@coreui/react'\nimport { DiscussionsAdd as AddDiscussion } from '../../../src/server/DiscussionsManagement'\nimport { UploadMedia } from '../../../src/server/MediasManagement'\nimport { CategoriesList as CallCategoriesList } from '../../../src/server/CategoriesManagement'\n\n\n\nconst DiscussionsAdd = () => {\n    const [categories, setCategories] = useState([])\n    const [mediaFile, setMediaFile] = useState()\n    const [addingLoader, setaddingLoader] = useState(false)\n    const [discussion, setDiscussion] = useState(false)\n    const [toastMessages, setToastMessage] = useState([])\n    const loadCategories = async () => {\n        const response = await CallCategoriesList()\n        const Categories = (await response.json()).data\n        setCategories(Categories)\n    }\n    const handleAdd = async (ev) => {\n        ev.preventDefault()\n        discussion.medias = []\n        setaddingLoader(true)\n        const addDiscussionCallback = async function (mediaId) {\n            if (mediaId !== -1) {\n                let addObject = {\n                    title: discussion.title,\n                    description: discussion.description,\n                    category: discussion.category ? discussion.category : categories[0]._id,\n                    isPublic: discussion.isPublic ? discussion.isPublic.toString() : 'true',\n                }\n                if (mediaId !== -2) {\n                    addObject.medias = [mediaId]\n                }\n                const response = await AddDiscussion(addObject)\n                if (response.ok) {\n                    setToastMessage([\n                        { title: 'Congrats!', description: 'The ' + discussion.title + ' discussion has been successfuly created', type: 'success' }\n                    ])\n                }\n                else {\n                    setToastMessage([\n                        { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n                    ])\n                }\n            }\n            setaddingLoader(false)\n        }\n        if (mediaFile)\n            await UploadMedia(mediaFile, setToastMessage, addDiscussionCallback)\n        else\n            addDiscussionCallback(-2)\n    }\n    useEffect(() => {\n        loadCategories()\n    }, [])\n    return (\n        <>\n            <CCard>\n                <CCardBody>\n                    <CRow>\n                        <CCol sm=\"12\">\n                            <h4 id=\"traffic\" className=\"card-title mb-0\">{'Add new discussion'}</h4>\n                            <div className=\"small text-muted\">{new Date().toDateString()}</div>\n                        </CCol>\n                    </CRow>\n                </CCardBody>\n            </CCard>\n            <CForm action=\"\" method=\"discussion\" onSubmit={handleAdd}>\n                <CRow>\n                    <CCol sm=\"12\">\n                        <CCard>\n                            <CCardBody>\n                                <CFormGroup>\n                                    <CLabel htmlFor=\"title\">Discussion Title</CLabel>\n                                    <CInput type=\"text\" id=\"title\" required placeholder=\"Enter title...\" onInput={(ev) => setDiscussion({ ...discussion, title: ev.target.value })} autoComplete=\"name\" />\n                                </CFormGroup>\n                                <CFormGroup row>\n                                    <CLabel col md=\"1\" htmlFor=\"file-input\">Image/Video</CLabel>\n                                    <CCol xs=\"12\" md=\"9\" className=\"ml-n3 mt-1\">\n                                        <CInputFile id=\"file-input\" name=\"file-input\" onChange={(ev) => setMediaFile(ev.target.files[0])} />\n                                    </CCol>\n                                </CFormGroup>\n                                <CFormGroup row>\n                                    <CCol xs=\"12\" sm=\"3\">\n                                        <CLabel htmlFor=\"select\">Category</CLabel>\n                                        <CSelect custom name=\"category\" id=\"category\" required onChange={(ev) => { setDiscussion({ ...discussion, category: ev.target.value }) }}>\n                                            {categories.filter(category => category.type === 'general').map(category => {\n                                                return <option key={category._id} value={category._id}>{category.name}</option>\n                                            })}\n                                        </CSelect>\n                                    </CCol>\n                                </CFormGroup>\n                                <CFormGroup row>\n                                    <CCol tag=\"label\" sm=\"3\" className=\"col-form-label\">\n                                        I want to publish this discussion:\n                                    </CCol>\n                                    <CCol sm=\"1\" className=\"ml-n5\">\n                                        <CSwitch\n                                            onChange={(ev) => setDiscussion({ ...discussion, isPublic: ev.target.checked })}\n                                            className=\"ml-n5 mt-1\"\n                                            color=\"info\"\n                                            defaultChecked\n                                        />\n                                    </CCol>\n                                </CFormGroup>\n                                <CFormGroup>\n                                    <CLabel htmlFor=\"textarea-input\">Description</CLabel>\n                                    <CTextarea rows=\"6\" name=\"description\" id=\"description\" onInput={(ev) => setDiscussion({ ...discussion, description: ev.target.value })}></CTextarea>\n                                </CFormGroup>\n                            </CCardBody>\n                            <CCardFooter className=\"d-flex\">\n                                <CButton type=\"submit\" size=\"md\" className=\"btn btn-info\">Add Discussion</CButton> <CLink size=\"sm\" className=\"btn btn-danger ml-2\">Cancel</CLink>\n                                {addingLoader ? <div className=\"w-25\"><CSpinner className=\"ml-2\" /></div> : null}\n                            </CCardFooter>\n                        </CCard>\n                    </CCol>\n                </CRow>\n            </CForm>\n            {toastMessages.map(toastMessage => {\n                return <CToaster\n                    position={'bottom-right'}\n                    key={'toaster' + toastMessages.id}\n                >\n                    {\n                        <CToast\n                            key={Math.floor(Math.random() * 1000000)}\n                            show={true}\n                            autohide={3000}\n                            fade={true}\n                            color={toastMessage.type}\n                        >\n                            <CToastHeader closeButton={true}>\n                                {toastMessage.title}\n                            </CToastHeader>\n                            <CToastBody>\n                                {toastMessage.description}\n                            </CToastBody>\n                        </CToast>\n                    }\n                </CToaster>\n            })\n            }\n        </>\n    )\n}\n\nexport default DiscussionsAdd\n","// importing GetUrl from the server\nimport GetUrl from \"../server/ApiEndpoints\";\n\n// Getting the token from the local storage\nlet bearerToken = \"Bearer \" + localStorage.getItem(\"HDI-token\");\n\n// Getting the categories list using url from the server by using GET method and if its not successful it will display an error message\nconst CategoriesList = async function () {\n    return await fetch(GetUrl(\"CategoriesList\"), {\n        method: \"GET\",\n        mode: \"cors\",\n        headers: {\n            Authorization: bearerToken,\n            Accept: \"application/json\"\n        }\n    }).catch(error => {\n        console.log(error.message);\n    });\n};\n\n// Editing the categories list using url from the server by using PATCH method and also stringifying the object and if its not successful it will display an error message\nconst CategoriesEdit = async function (id, editObject, setToastMessage) {\n    return fetch(GetUrl(\"CategoriesEdit\") + \"/\" + id, {\n        method: \"PATCH\",\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: bearerToken,\n            Accept: \"application/json\"\n        },\n        body: JSON.stringify(editObject)\n    })\n        .then(response => {\n            return response;\n        })\n        .catch(error => {\n            console.log(error);\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        });\n};\n\nconst CategoriesDelete = async function (id, setToastMessage) {\n    return fetch(GetUrl(\"CategoriesDelete\") + \"/\" + id, {\n        method: \"DELETE\",\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: bearerToken,\n            Accept: \"application/json\"\n        }\n    })\n        .then(response => {\n            return response;\n        })\n        .catch(error => {\n            console.log(error);\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        });\n};\n\n// Adding a new Category. if its not successful it will display an error message\nconst CategoriesAdd = async function (addObject, setToastMessage) {\n    return fetch(GetUrl(\"CategoriesAdd\"), {\n        method: \"POST\",\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: bearerToken,\n            Accept: \"application/json\"\n        },\n        body: JSON.stringify(addObject)\n    })\n        .then(response => {\n            return response;\n        })\n        .catch(error => {\n            console.log(error)\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        });\n};\n\n// exporting the categoriesList and categoriesEdit functions\nexport { CategoriesList, CategoriesEdit, CategoriesAdd, CategoriesDelete };","import GetUrl from '../server/ApiEndpoints'\nimport AWS from 'aws-sdk'\n\nconst ID = 'AKIAWBK3UNFZVVF7OF4B';\nconst SECRET = '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';\nconst BUCKET_NAME = 'indigenous-images';\nconst s3 = new AWS.S3({\n    accessKeyId: ID,\n    secretAccessKey: SECRET\n});\nlet bearerToken = 'Bearer ' + localStorage.getItem('HDI-token')\n\nconst MediasAdd = async function (addObject, setToastMessage) {\n    return fetch(GetUrl('MediasAdd'), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': bearerToken,\n            'Accept': 'application/json',\n        },\n        body: JSON.stringify(addObject)\n    })\n        .then(response => {\n            return response\n        })\n        .catch(error => {\n            console.log(error)\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        })\n}\n\nconst UploadMedia = async function (fileContent, setToastMessage, callback) {\n    const params = {\n        Bucket: BUCKET_NAME,\n        Key: Math.floor(Math.random() * 10000000000).toString(),\n        Body: fileContent,\n        ContentType: 'image/jpeg',\n        ACL: 'public-read-write'\n    };\n\n    s3.upload(params, async function (err, data) {\n        if (err) {\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request: ' + err, type: 'danger' }\n            ])\n        }\n        console.log(`File uploaded successfully.`, data);\n        let response = await MediasAdd({ type: 'image', extension: '.' + fileContent.name.split('.')[1], path: data.Location }, setToastMessage)\n        if (response.ok) {\n            let jsonResult = await response.json()\n            await callback(jsonResult.data._id)\n        }\n        else {\n            await callback(-1)\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request: ' + err, type: 'danger' }\n            ])\n        }\n    })\n}\n\nconst UploadManyMedias = async function (fileContents, setToastMessage, callback) {\n    let promises = []\n    fileContents.forEach(fileContent => {\n        const params = {\n            Bucket: BUCKET_NAME,\n            Key: Math.floor(Math.random() * 10000000000).toString(),\n            Body: fileContent.content,\n            ContentType: 'image/jpeg',\n            ACL: 'public-read-write'\n        };\n        promises.push({ type: fileContent.type, promise: s3.upload(params).promise() })\n    })\n    Promise.all(promises.map(pr => pr.promise)).then(async function (results) {\n        let mediaIds = []\n        for (let i = 0; i < results.length; i++) {\n            console.log(`File uploaded successfully.`, results[i]);\n            if (fileContents[i].type !== 'icon') {\n                let response = await MediasAdd({ type: 'image', extension: '.jpg', path: results[i].Location }, setToastMessage)\n                if (response.ok) {\n                    let jsonResult = await response.json()\n                    mediaIds.push(jsonResult.data._id)\n                }\n                else {\n                    setToastMessage([\n                        { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n                    ])\n                    return\n                }\n            }\n            else\n                mediaIds.push(results[i].Location)\n        }\n        await callback(mediaIds)\n    });\n}\n\nexport { UploadMedia, UploadManyMedias }","import GetUrl from '../server/ApiEndpoints'\nlet bearerToken = 'Bearer ' + localStorage.getItem('HDI-token')\n\nconst DiscussionsAdd = async function (addObject, setToastMessage) {\n    return fetch(GetUrl('DiscussionsAdd'), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': bearerToken,\n            'Accept': 'application/json',\n        },\n        body: JSON.stringify(addObject)\n    })\n        .then(response => {\n            return response\n        })\n        .catch(error => {\n            console.log(error)\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        })\n}\nconst DiscussionsList = async function () {\n    return await fetch(GetUrl('DiscussionsList'), {\n        method: 'GET',\n        mode: 'cors',\n        headers: {\n            'Authorization': bearerToken,\n            'Accept': 'application/json',\n        }\n    })\n        .catch(error => {\n            console.log(error.message)\n        })\n}\n\nconst DiscussionsDetail = async function (id) {\n    return await fetch(GetUrl('DiscussionsList') + '/' + id, {\n        method: 'GET',\n        mode: 'cors',\n        headers: {\n            'Authorization': bearerToken,\n            'Accept': 'application/json',\n        }\n    })\n        .catch(error => {\n            console.log(error.message)\n        })\n}\n\nconst DiscussionsEdit = async function (id, editObject, setToastMessage) {\n    return fetch(GetUrl('DiscussionsEdit') + '/' + id, {\n        method: 'PATCH',\n        mode: 'cors',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': bearerToken,\n            'Accept': 'application/json'\n        },\n        body: JSON.stringify(editObject)\n    })\n        .then(response => {\n            return response\n        })\n        .catch(error => {\n            console.log(error)\n            setToastMessage([\n                { title: 'Error!', description: 'An error occured while processing the request', type: 'danger' }\n            ])\n        })\n}\n\n\nexport { DiscussionsList, DiscussionsEdit, DiscussionsDetail, DiscussionsAdd }"],"sourceRoot":""}